

= Канадский кроссворд

Данная программа может решать и конфигурировать канадский кроссворд.

=== 1. Режимы пользования
  В кроссворде определены два режима:

* режим пользователя; +
* режим конфигуратора. +

==== 1.1 Пользователь может: +

* начать игру (в том числе заново); +
* видеть сам кроссворд и вопросы к нему; +
* вводить слово, которое оно считает ответом; +
* удалять уже установленное слово; +
* узнавать правильно ли он собрал кроссворд.

==== 1.2 Конфигуратор может:

* вводить вопрос и слово-ответ ; +
* собирать кроссворд из полученных слов.



=== 2. Программная реализация +
В реализации данной задачи использованы три пакета, взаимодействующие друг с другом. +

* process.
* logic;
* myView;


==== 2.1 Пакет process
Содержит классы с которых запускается программа. Он взаимодействут с пакетом logic и пакетом myView. +
Его содержимое: +

* class RunCrossword; +
** main - точка входа консольного приложения;
* class WorkProgram +
** void setMode(boolean mode) - устанавливает режим пользования (конфигурация или отгадывание);
** void startMenu(); - определяет как кто мы хотим работать +
** void actionMenu(); - вызов дейтвий +
** int takeCommand(); - взятие номера команды +

==== 2.2 Пакет logic
Содержит классы и интерфейсы с помощью, которых реализуется логика кроссворда. Он взаимодействут с пакетом myView. +
Определим структуру данных. +
Кроссворд представляет собой двумерный массив из ячеек в которых содержатся буквы. Но такой структуры данных +
недостаточно ввиду того, что нам надо хранить и слова. Поэтому мы определяем class Word, причем каждое слово будет +
состоять из ячеек (interface Cell). Слова будут устанавливаться в двухмерный массив из ячеек.
Получается: +

* interface Cell - реализует одну клетку кроссворда
** boolean isFull() - заполнена ли ячейка;
** boolean isStartWord() является ли ячейка началом слова;
** int getNumberStartWord - номер вопроса, если ячейка стартовая для ответа;
** int getX() - координата X в матрице;
** int getY() - координата Y в матрице;
** String isCorrectLetter() - правильная буква;
** String isHypothesisLetter() - предполагаемая пользователем буква;
** void setCorrectLetter() - установка правильной буквы;
** void hypothesisLetter() - установка предположения пользователя;
** void draw(T paint, boolean real) - отрисовка, paint полотно, real рисовать реальное значение или нет.

Слово будет состоять из ячеек (Cell). +

* class Word
** int getNumber() - номер слова;
** Cell[] getRealWord() - правильное значение;
** Cell[] getUserWord() - слово установленное пользователем;
** void setRealWord(String word) - установить правильное значение;
** void setUserWord(String word) - установить пользовательское слово;
** String getDescription() - получить вопрос к слову;
** void setDescription(String desc) - установить вопрос;
** boolean isHorisontal() - слово горизонтальное;
** boolean isVertical() - слово горизонтальное;
** int getStartX() - координата x;
** int getStartY() - координата y;
** int getLength() - получить длину;

Реализация действий, указанных в пункте 1.1, гарантируется классом User. +

* class User
** void initGame() - инициализация игры;
** void enterWord() - ввести слово;
** void deleteWord() - удалить введенное слово;
** void questionsRequestCroosword() - запрос собран ли кроссворд.

Здесь возникает необходимость ввести системного пользователя к которому будет обращаться, как пользователь, так +
 и конфигуратор и который будет выполнять действия с кроссвордом, хранить его и выдавать на экран. +

* class SystemUser
** boolean checkCompletedCrossword() - проверить собран ли кроссворд;
** void configureCrosssword(List<Word> words, int widthCrossword, int heightCrossword) - сборка кроссворда;
** void saveCrossword() - сохранение кроссворда;
** Cell[][] getCrossword() - получение кроссворда.

Реализация действий, указанных в пункте 1.2, гарантируется классом Configurator. +

* class ConfiguratorAction
** void enterSize() - ввод размера кроссворда;
** void enterWordWithDescription() - ввод слова с описанием;
** void configure() - конфигурация кроссворда.

Также определим класс LogicCrossword в котором определяется основная логика сборки кроссворда.

* class LogicCrossword
** Cell[][] cells - двумерный массив ячеек;
** List<Word> words - список слов;
** LogicCrossword(List<Word> words, int width, int height) - конструктор;
** void setWord(Word word, int startX, int startY, boolean isHorisontal) - установить слово;
** void deleteWord(Word word) - удалить слово;
** void searchOptimalPlace() - поиск оптимальгого слова;
** void start() - начало конфигурации;
** Cell[][] getResult() - получение результата  в виде двумерного массива;
** List<Word> getWords() - получение списка слов.


==== 2.3 Пакет myView
Пакет myView отвечает за представление кроссворда. Он взаимодейсвует с пакетом logic. Кроссворд будет выводиться в консоли, сам он будет посередине, +
с двух сторон вопросы и внизу будет область ввода действий. +
Определим класс доски кроссворда. +

* class ConsoleCrosswordBoard
** private Cell[][] cells;
** void drawCrossBoard(Cell[][] cells, List<Word> questions) - рисут доску с вопросами;
** void drawCell(int x, int y) - рисует ячейку;
** void drawMessageFinish() - рисует сообщение о сборки кроссворда.

Реализуем консольное представление ячейки кроссворда (описание методов см. выше).

* class ConsoleCrosswordCell implements Cell<PrintStream>
** boolean isFull();
** int getX();
** int getY();
** int startNumberWord();
** String isCorrectLetter();
** String isHypothesisLetter();
** void setCorrectLetter();
** void hypothesisLetter();
** void draw(PrintStream paint, boolean real).


=== 3. Алгоритм формирования кросссворда
Слова будут генерироваться в последовательности, зависящей в первую очередь, от их длины. Чем длиннее слово, +
тем больше у него может быть пересечений и тем труднее будет найти слово для установки. Напротив, самые короткие +
слова, длиной в 2 или 3 буквы, будут иметь минимальное количество пересечений и их максимально удобно подбирать +
на завершающем этапе генерации. слова у нас расположены в такой последовательности, которая не гарантирует пересечение +
двух соседних слов между собой. Это означает, что если мы не нашли слово для установки, тогда нужно изменить не +
предыдущее слово, а одно из ранее установленных слов, которые пересекаются с этим словом и по сути задают для него +
условия подбора. Логично из всех ранее установленных слов-пересечений, заменить слово, установленное последним, чтобы откатиться на минимальное количество слов генерации.

=== 4. Cредства реализации
Программа представляет собой Maven проект, написанный на Java с использованием JUnit библиотеки и следующих +
классов, входящих в основной Java пакет:

* java.lang;
* java.util.List;
* java.io.PrintStream;
* java.util.Scanner;

=== 5. Минимальные требования к программному обеспечению
Наличие на компьютере минимум 2 Гб ОЗУ, наличие Java Virtual Machine.




